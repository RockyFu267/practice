package medium

// 现有一个下标从 1 开始的 8 x 8 棋盘，上面有 3 枚棋子。

// 给你 6 个整数 a 、b 、c 、d 、e 和 f ，其中：

// (a, b) 表示白色车的位置。
// (c, d) 表示白色象的位置。
// (e, f) 表示黑皇后的位置。
// 假定你只能移动白色棋子，返回捕获黑皇后所需的最少移动次数。

// 请注意：

// 车可以向垂直或水平方向移动任意数量的格子，但不能跳过其他棋子。
// 象可以沿对角线方向移动任意数量的格子，但不能跳过其他棋子。
// 如果车或象能移向皇后所在的格子，则认为它们可以捕获皇后。
// 皇后不能移动。
// 11 12 13 14 15 16 17 18
// 21 22 23 24 25 26 27 28
// 31 32 33 34 35 36 37 38
// 41 42 43 44 45 46 47 48
// 51 52 53 54 55 56 57 58
// 61 62 63 64 65 66 67 68
// 71 72 73 74 75 76 77 78
// 81 82 83 84 85 86 87 88

// 如果 白色象、黑皇后 处在同一条对角线或者 白色车、黑皇后 处于同一条线上，此时可能只需要 1 次移动即可捕获 黑皇后，根据题意分析如下：

// 如果 白色象 与 黑皇后 处在同一条对角线时，且此时该路径上无 白色车 阻挡时，此时只需移动 1 次即可捕获 黑皇后；

// 如果 白色车 与 黑皇后 处在同一行或者同一列时，且此时二者移动路线之间无 白色象 阻挡时，此时只需移动 1 次即可捕获 黑皇后；

// 其余情况下，白色车 最多需要 2 次移动即可捕获 黑皇后；

// minMovesToCaptureTheQueen 捕获黑皇后
func minMovesToCaptureTheQueen(a int, b int, c int, d int, e int, f int) int {
	// 车与皇后处在同一行，且中间没有象
	if a == e && (c != a || d <= min(b, f) || d >= max(b, f)) {
		return 1
	}
	// 车与皇后处在同一列，且中间没有象
	if b == f && (d != b || c <= min(a, e) || c >= max(a, e)) {
		return 1
	}
	// 象、皇后处在同一条对角线，且中间没有车
	if abs(c-e) == abs(d-f) && ((c-e)*(b-f) != (a-e)*(d-f) || a < min(c, e) || a > max(c, e)) {
		return 1
	}
	return 2
}

//	func minMovesToCaptureTheQueen(a int, b int, c int, d int, e int, f int) int {
//		// 白色车 与 黑皇后 处在同一行或者同一列时，且此时二者移动路线之间无 白色象 阻挡时，此时只需移动 1 次即可捕获 黑皇后；
//		if (a == e || b == f) && (c != a || d <= min(b, f) || d >= max(b, f)) {
//			return 1
//		}
//		// 白色象 与 黑皇后 处在同一条对角线时，且此时该路径上无 白色车 阻挡时，此时只需移动 1 次即可捕获 黑皇后；
//		if abs(c-e) == abs(d-f) && ((c-e)*(b-f) != (a-e)*(d-f) || a < min(c, e) || a > max(c, e)) {
//			return 1
//		}
//		// 其余情况下，白色车 最多需要 2 次移动即可捕获 黑皇后；
//		return 2
//	}
func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func min(x, y int) int {
	if x <= y {
		return x
	}
	return y
}
func max(x, y int) int {
	if x <= y {
		return y
	}
	return x
}
